plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
dimdesc(res.pca, axes=c(1,2))
resultat_CAH = HCPC(resultat_acm)
resultat_CAH = HCPC(res.pca)
View(table_qualite)
View(table_qualite)
table_qualite<-subset(scraping_merge, distance_geo>0,
select = c("position_page","meilleure_dist_jw","distance_geo","is_equals"))
res.pca = PCA(table_qualite, scale.unit=TRUE,              quali.sup=4, ncp=2, graph=T)
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
res.pca = PCA(table_qualite, scale.unit=TRUE,              quali.sup=4, ncp=2, graph=T)
dimdesc(res.pca, axes=c(1,2))
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
res.pca$var
table_qualite<-subset(scraping_merge,
select = c("position_page","meilleure_dist_jw","distance_geo","is_equals"))
res.pca = PCA(table_qualite, scale.unit=TRUE,quali.sup=4, ncp=2, graph=T)
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
res.pca$ind
res.pca$ind$coord
res.pca$ind$coord[dim.1]
res.pca$ind$coord["dim.1"]
res.pca$ind$coord
res.pca$ind$coord["Dim.1"]
res.pca$ind$coord["Dim.1",]
res.pca$ind$coord[,"Dim.1"]
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
View(scraping_merge)
?hist
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$Dim.1), col = "green", main = "Score synthétique
en fonction de match ou non")
projectionT$Dim.1
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1)
?duplicated
?unique
write.csv(scraping_merge, "C:/Users/maxim/Documents/Hackathon_Insee.git/données/table_qualite_comp.csv")
?unique
duplicated(scraping_merge, by= c("cabbi","siret"))
anyDuplicated(scraping_merge, by= c("cabbi","siret"))
?sort
?dplyr
install.packages("dplyr")
install.packages("dplyr")
trie <- distinct(scraping_merge2, "scraping_merge2$cabbi","scraping_merge2$siret")
library(dplyr)
trie <- distinct(scraping_merge2, "scraping_merge2$cabbi","scraping_merge2$siret")
library(dplyr)
update.packages("tibble")
library(dplyr)
install.packages("tibble")
library(stringdist)
library(stringi)
library(tm)
library(stringr)
library(readr)
library(data.table)
library(FactoMineR)
library(dplyr)
options(scipen=999)
library(stringdist)
library(stringi)
library(tm)
library(stringr)
library(readr)
library(data.table)
library(FactoMineR)
library(dplyr)
options(scipen=999)
scraping <- read.csv2("C:/Users/maxim/Documents/Hackathon_Insee.git/données/scrapping_1000 lignes.csv",
numerals="no.loss", stringsAsFactors = F)
scraping <- read.csv2("C:/Users/maxim/Documents/Hackathon_Insee.git/données/no doublon_final.csv",
numerals="no.loss", stringsAsFactors = F)
scraping$siret<-str_pad(scraping$siret, 14, side = c("left"), pad = "0")
scraping_merge <- merge(scraping, sirus, by.x = "siret", by.y = "siret", all.x = T, all.y = F)
View(scraping_merge)
View(scraping_merge)
### Nettoyage texte
nettoyage <- function(texte) {
documents <- Corpus(VectorSource(texte))
# Suppression Accents
accent <- function(x) stri_trans_general(x, "Latin-ASCII") # cela signifie qu'on remplace un caractère encodé en Latin1 par son équivalent le plus proche en ASCII, il n'y a par exemple pas de caractères accentués en ASCII
documents <- tm_map(documents, content_transformer(accent))
# On garde chiffres et lettres seulement
documents <- tm_map(documents, content_transformer(gsub), pattern = "[^a-zA-Z0-9]", replacement = " ")
# Passage minuscule
documents <- tm_map(documents, content_transformer(tolower))
documents <- tm_map(documents, stripWhitespace) #n'enleve pas le tout premier espace
documents <- tm_map(documents, content_transformer(gsub), pattern = "^\\s+", replacement = "")
return(documents$content)
}
?stringdist
calcul_matching_jw <- function(table) {
# Nettoyage
table_travail <- table
table_travail$nettoyeA <- nettoyage(table_travail$rs_rp)
table_travail$nettoyeB1 <- nettoyage(table_travail$denom)
table_travail$nettoyeB2<- nettoyage(table_travail$denom_condense)
table_travail$nettoyeB3<- nettoyage(table_travail$enseigne_et1)
table_travail$nettoyeB4<- nettoyage(table_travail$nom_comm_et)
table_travail$nettoyeB5 <- nettoyage(table_travail$sigle)
table_travail$dist1 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB1, method = "jw")
table_travail$dist2 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB2, method = "jw")
table_travail$dist3 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB3, method = "jw")
table_travail$dist4 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB4, method = "jw")
table_travail$dist5 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB5, method = "jw")
table_travail[is.na(table_travail)] <- 1
distance_meilleure <- with(table_travail, pmin(dist1, dist2, dist3, dist4))
return(distance_meilleure)
}
scraping_merge$meilleure_dist_jw<- calcul_matching_jw(scraping_merge)
scraping_merge$x_rpnum<-as.numeric(scraping_merge$x_rp)
scraping_merge$y_rpnum<-as.numeric(scraping_merge$y_rp)
scraping_merge$distance_geo <- sqrt((scraping_merge$x_rpnum-scraping_merge$x)^2 + (scraping_merge$y_rpnum-scraping_merge$y)^2)
table(scraping_merge$distance_geo, scraping_merge$is_equals)
table(scraping_merge$meilleure_dist_jw, scraping_merge$is_equals)
table(scraping_merge$distance_geo, scraping_merge$is_equals)
View(scraping_merge)
table_qualite<-subset(scraping_merge,
select = c("position_page","meilleure_dist_jw","distance_geo","is_equals"))
res.pca = PCA(table_qualite, scale.unit=TRUE,quali.sup=4, ncp=2, graph=T)
res.pca$ind
dimdesc(res.pca, axes=c(1,2))
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
table(scraping_merge$is_equals)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1)
View(scraping_merge)
View(scraping_merge)
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
write.csv(scraping_merge, "E:/eval/table_qualite.csv")
scraping$siret<-str_pad(scraping$siret, 14, side = c("left"), pad = "0")
scraping <- read.csv2("C:/Users/maxim/Documents/Hackathon_Insee.git/données/no doublon_final.csv",
numerals="no.loss", stringsAsFactors = F)
scraping$siret<-str_pad(scraping$siret, 14, side = c("left"), pad = "0")
scraping_merge <- merge(scraping, sirus, by.x = "siret", by.y = "siret", all.x = T, all.y = F)
nettoyage <- function(texte) {
documents <- Corpus(VectorSource(texte))
# Suppression Accents
accent <- function(x) stri_trans_general(x, "Latin-ASCII") # cela signifie qu'on remplace un caractère encodé en Latin1 par son équivalent le plus proche en ASCII, il n'y a par exemple pas de caractères accentués en ASCII
documents <- tm_map(documents, content_transformer(accent))
# On garde chiffres et lettres seulement
documents <- tm_map(documents, content_transformer(gsub), pattern = "[^a-zA-Z0-9]", replacement = " ")
# Passage minuscule
documents <- tm_map(documents, content_transformer(tolower))
documents <- tm_map(documents, stripWhitespace) #n'enleve pas le tout premier espace
documents <- tm_map(documents, content_transformer(gsub), pattern = "^\\s+", replacement = "")
return(documents$content)
}
nettoyage(scraping_merge$rs_rp
### Calcul distance - Jaro Winkler
### Variables à prendre en compte pour potentiel matching
# denom
# denom_condense
# enseigne_et1
# nom_comm_et
# sigle
calcul_matching_jw <- function(table) {
# Nettoyage
table_travail <- table
table_travail$nettoyeA <- nettoyage(table_travail$rs_rp)
table_travail$nettoyeB1 <- nettoyage(table_travail$denom)
table_travail$nettoyeB2<- nettoyage(table_travail$denom_condense)
table_travail$nettoyeB3<- nettoyage(table_travail$enseigne_et1)
table_travail$nettoyeB4<- nettoyage(table_travail$nom_comm_et)
table_travail$nettoyeB5 <- nettoyage(table_travail$sigle)
table_travail$dist1 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB1, method = "jw")
table_travail$dist2 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB2, method = "jw")
table_travail$dist3 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB3, method = "jw")
table_travail$dist4 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB4, method = "jw")
table_travail$dist5 <- stringdist(table_travail$nettoyeA,table_travail$nettoyeB5, method = "jw")
table_travail[is.na(table_travail)] <- 1
distance_meilleure <- with(table_travail, pmin(dist1, dist2, dist3, dist4))
return(distance_meilleure)
}
table(scraping_merge$indicateur_synthetique)
scraping_merge$meilleure_dist_jw<- calcul_matching_jw(scraping_merge)
scraping_merge$x_rpnum<-as.numeric(scraping_merge$x_rp)
scraping_merge$y_rpnum<-as.numeric(scraping_merge$y_rp)
scraping_merge$distance_geo <- sqrt((scraping_merge$x_rpnum-scraping_merge$x)^2 + (scraping_merge$y_rpnum-scraping_merge$y)^2)
table(scraping_merge$distance_geo, scraping_merge$is_equals)
table(scraping_merge$meilleure_dist_jw, scraping_merge$is_equals)
### ACP
table_qualite<-subset(scraping_merge,
select = c("position_page","meilleure_dist_jw","distance_geo","is_equals"))
res.pca = PCA(table_qualite, scale.unit=TRUE,quali.sup=4, ncp=2, graph=T)
res.pca$ind
dimdesc(res.pca, axes=c(1,2))
plot.PCA(res.pca, axes=c(1, 2), choix="ind", habillage=4)
scraping_merge["indic_synthetique"]<-res.pca$ind$coord[,"Dim.1"]
table(scraping_merge$indic_synthetique, scraping_merge$is_equals)
max.print
write.csv(scraping_merge, "E:/eval/table_qualite.csv")
?round
temp$indic_arrondi <- round(temp$indic_synthetique, digits =1)
temp<-scraping_merge
temp$indic_arrondi <- round(temp$indic_synthetique, digits =1)
table(temp$indic_arrondi, temp$is_equals)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non")
lines(density(projectionF$indic_synthetique), col = "red")
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1)
?density
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non", lwd=3)
lines(density(projectionF$indic_synthetique), col = "red")
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1, lwd = 3)
write.csv(scraping_merge, "E:/eval/table_qualite.csv")
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non", lwd=3)
lines(density(projectionF$indic_synthetique), col = "red", lwd = 3)
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1,)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non", lwd=5)
lines(density(projectionF$indic_synthetique), col = "red", lwd = 5)
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1,lwd = 5)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique
en fonction de match ou non", lwd=8)
lines(density(projectionF$indic_synthetique), col = "red", lwd = 8)
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1,lwd = 5)
projectionT <- subset(scraping_merge, scraping_merge$is_equals == "True")
projectionF <- subset(scraping_merge, scraping_merge$is_equals == "False")
plot(density(projectionT$indic_synthetique), col = "green", main = "Score synthétique", lwd=8)
lines(density(projectionF$indic_synthetique), col = "red", lwd = 8)
legend("topright", 95, legend=c("Match", "Non match"),
col=c("green", "red"), lty=1,lwd = 5)
table_qualite<-subset(scraping_merge,
select = c("position_page","meilleure_dist_jw","distance_geo","is_equals"))
res.pca = PCA(table_qualite, scale.unit=TRUE,quali.sup=4, ncp=2, graph=T)
res.pca$ind
dimdesc(res.pca, axes=c(1,2))
install.packages("swirl")
swirl()
library(swirl)
swirl()
5+6
5+7
x -5+7
x <- 5+7
x
y <- x-3
y
z <- c(1.1, 9,
| 3.14)
z <- c(1.1, 9,3.14)
?c
z
c(z,555,z)
z*2+1000
z*2+100
my_sqrt <- sqrt(z) -1
my_sqrt <- sqrt(z-1)
my_sqrt
my_div <- z/my_sqrt
my_div
c(1,2,3,4)+c(1,10)
c(1,2,3,4)+c(0,10)
c(1, 2, 3, 4) + c(0, 10, 100)
z*2+1000
my_div
?solve
setwd("C:\Users\maxim\Documents\ensae-statapp-2019\Data\Données tarification\2018")
setwd("C:/Users/maxim/Documents/ensae-statapp-2019/Data/Données tarification/2018")
public2018 <- read.csv("ghs_pub.csv")
public2018 <- read.csv("ghs_pub.csv", sep = ";")
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE)
summary(public2018)
?read.csv
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE
, colClasses = c("integer", "integer", "character", "character",
"character", "integer", "integer","numeric",
"numeric", "numeric", "numeric", "date"))
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE
, colClasses = c("integer", "character", "character", "character",
"character", "integer", "integer","numeric",
"numeric", "numeric", "numeric", "date"))
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE, dec = ","
, colClasses = c("integer", "integer", "character", "character",
"character", "integer", "integer","numeric",
"numeric", "numeric", "numeric", "date"))
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE, dec = ","
)
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE, dec = ",")
summary(public2018)
View(public2018)
View(public2018)
gravite <- subset(public2018, substr(public2018$GHM.NRO, 1, 5)== "1")
?substr
gravite <- subset(public2018, substr(public2018$GHM.NRO, 5, 5)== "1")
View(gravite)
View(gravite)
View(gravite)
gravite1 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "1")
gravite1 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "1")
gravite2 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "2")
gravite3 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "3")
gravite4 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "4")
plot(density(projection1$Dim.1), col = "blue", main = "Remboursement du séjour selon la gravité")
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
gravite1 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "1")
gravite2 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "2")
gravite3 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "3")
gravite4 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "4")
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
lines(density(gravite2$GHS.PRI), col = "green")
lines(density(gravite3$GHS.PRI), col = "red")
lines(density(gravite4$GHS.PRI), col = "orange")
legend("topright", 95, legend=c("Gravité 1", "Gravité 2", "Gravité 3", "Gravité 4"),
col=c("blue", "green", "red", "orange"), lty=1)
public2018$GHS.PRI<-log(public2018$GHS.PRI)
?hist
gravite1 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "1")
gravite2 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "2")
gravite3 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "3")
gravite4 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "4")
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
lines(density(gravite2$GHS.PRI), col = "green")
lines(density(gravite3$GHS.PRI), col = "red")
lines(density(gravite4$GHS.PRI), col = "orange")
legend("topright", 95, legend=c("Gravité 1", "Gravité 2", "Gravité 3", "Gravité 4"),
col=c("blue", "green", "red", "orange"), lty=1)
plot(density(public2018$GHS.PRI), col = "blue", main = "Remboursement du séjour (euros) selon le GHM")
public2018 <- read.csv("ghs_pub.csv", sep = ";", stringsAsFactors = FALSE, dec = ",")
## Descriptif des variables
summary(public2018)
## Variable tarification
# Au global
plot(density(public2018$GHS.PRI), col = "blue", main = "Remboursement du séjour (euros) selon le GHM")
## Plot des variables numériques
public2018$logGHSPrix <- log(public2018$GHS.PRI)
plot(density(public2018$SEU.BAS), col = "blue", main = "Seuil bas du nb de jours d'hospitalisation")
hist(public2018$SEU.BAS), col = "blue", main = "Seuil bas du nb de jours d'hospitalisation"))
hist(public2018$SEU.BAS, col = "blue", main = "Seuil bas du nb de jours d'hospitalisation"))
hist(public2018$SEU.BAS, col = "blue", main = "Seuil bas du nb de jours d'hospitalisation")
hist(public2018$SEU.BAS, col = "red", main = "Seuil haut du nb de jours d'hospitalisation")
hist(public2018$SEU.HAUT, col = "red", main = "Seuil haut du nb de jours d'hospitalisation")
hist(public2018$SEU.HAU, col = "red", main = "Seuil haut du nb de jours d'hospitalisation")
p1 <- hist(public2018$SEU.BAS)
p2 <- hist(public2018$SEU.HAU)
plot(p1, col="red", xlim=c(0,10))
plot(p2, col="blue", xlim=c(0,10), add=T)
p1 <- hist(public2018$SEU.BAS)
p2 <- hist(public2018$SEU.HAU)
plot(p1, col="red")
plot(p2, col="blue", add=T)
p1 <- hist(public2018$SEU.BAS)
p2 <- hist(public2018$SEU.HAU)
plot(p2, col="red")
plot(p1, col="blue", add=T)
?hist
p2 <- hist(public2018$SEU.HAU)
plot(p2, col="red" )
plot(p1, col="red",xlim=c(0,200))
plot(p2, col="blue", add=T)
### Découverte base de données tarification données de santé ###
## QUelques statistiques descriptives
## 10 novembre 2018
library(ggplot2)
ggplot(public2018, aes(GHS.PRI, fill =  substr(public2018$GHM.NRO, 6, 6)) + geom_density(alpha = 0.2)
ggplot(public2018, aes(GHS.PRI, fill =  substr(public2018$GHM.NRO, 6, 6))) + geom_density(alpha = 0.2)
ggplot(public2018, aes(GHS.PRI, fill =  substr(public2018$GHM.NRO, 6, 6))) + geom_density(alpha = 0.2)
ggplot(public2018, aes(logGHSPrix, fill =  substr(public2018$GHM.NRO, 6, 6))) + geom_density(alpha = 0.2)
public2018$Gravite <- "XXXXXXX"
public2018$Gravite <- as.char(substr(public2018$GHM.NRO, 6, 6))
public2018$Gravite <- as.character(substr(public2018$GHM.NRO, 6, 6))
table(public2018$Gravite)
public2018$Gravite[public2018$Gravite %not% %in% c("1", "2", "3", "4")] <- "Autre"
public2018$Gravite[public2018$Gravite != c("1", "2", "3", "4")] <- "Autre"
public2018 <- transform(public2018, Gravite= ifelse(Gravite == "1", "X", "2"))
table(public2018$Gravite)
public2018$Gravite <- as.character(substr(public2018$GHM.NRO, 6, 6))
table(public2018$Gravite)
public2018 <- transform(public2018, Gravite= if(Gravite == "A", "X"))
public2018 <- transform(public2018, Gravite= (if(Gravite == "A", "X"))
public2018$Gravite[public2018$Gravite %not% %in% c("1", "2", "3", "4")] = -1
public2018$Gravite[public2018$Gravite %in% c("1", "2", "3", "4")] = -1
table(public2018$Gravite)
public2018$Gravite[!(public2018$Gravite %in% c("1", "2", "3", "4"))] = "Autre"
table(public2018$Gravite)
public2018$Gravite <- as.character(substr(public2018$GHM.NRO, 6, 6))
public2018$Gravite[!(public2018$Gravite %in% c("1", "2", "3", "4"))] = "Autre"
ggplot(public2018, aes(logGHSPrix, fill =  substr(public2018$GHM.NRO, 6, 6))) + geom_density(alpha = 0.2)
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite) + geom_density(alpha = 0.2)
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2)
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2)
?ggplot
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2)
title("coucou")
title("coucou")
title("coucou")
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2)
+ ggtitle("Logarithme du prix du GHM selon sa gravité")
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2) + ggtitle("Logarithme du prix du séjour selon sa gravité")
# Prix
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
lines(density(gravite2$GHS.PRI), col = "green")
lines(density(gravite3$GHS.PRI), col = "red")
lines(density(gravite4$GHS.PRI), col = "orange")
legend("topright", 95, legend=c("Gravité 1", "Gravité 2", "Gravité 3", "Gravité 4"),
col=c("blue", "green", "red", "orange"), lty=1)
# Selon la gravité
?hist
gravite1 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "1")
gravite2 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "2")
gravite3 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "3")
gravite4 <- subset(public2018, substr(public2018$GHM.NRO, 6, 6)== "4")
# Prix
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
lines(density(gravite2$GHS.PRI), col = "green")
lines(density(gravite3$GHS.PRI), col = "red")
lines(density(gravite4$GHS.PRI), col = "orange")
legend("topright", 95, legend=c("Gravité 1", "Gravité 2", "Gravité 3", "Gravité 4"),
col=c("blue", "green", "red", "orange"), lty=1)
# Log Prix : avec package ggplot
public2018$Gravite <- as.character(substr(public2018$GHM.NRO, 6, 6))
public2018$Gravite[!(public2018$Gravite %in% c("1", "2", "3", "4"))] = "Autre"
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2) + ggtitle("Logarithme du prix du séjour selon sa gravité")
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2) + ggtitle("Logarithme du prix du séjour selon sa gravité")
# Au global
plot(density(public2018$GHS.PRI), col = "blue", main = "Remboursement du séjour (euros) selon le GHM")
p1 <- public2018$SEU.BAS
p2 <- public2018$SEU.HAU
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,100), main = "Seuils sur nb de jours d'hospitalisation")
p1 <- hist(public2018$SEU.BAS)
p2 <- hist(public2018$SEU.HAU)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,100), main = "Seuils sur nb de jours d'hospitalisation")
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,100), add=T)
p1 <- hist(public2018$SEU.BAS)
p1 <- hist(public2018$SEU.BAS)
p1 <- hist(public2018$SEU.BAS)
p1 <- hist(public2018$SEU.BAS)
p2 <- hist(public2018$SEU.HAU)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,100), breaks = 100, main = "Seuils sur nb de jours d'hospitalisation")
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,100), breaks = 100, add=T)
p1 <- hist(public2018$SEU.BAS, breaks = 100)
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,100), add=T)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,100),main = "Seuils sur nb de jours d'hospitalisation")
p1 <- hist(public2018$SEU.BAS, breaks = 100)
p2 <- hist(public2018$SEU.HAU, breaks = 100)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,100),main = "Seuils sur nb de jours d'hospitalisation")
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,100), add=T)
p1 <- hist(public2018$SEU.BAS, breaks = 50)
p2 <- hist(public2018$SEU.HAU, breaks = 50)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,50),main = "Seuils sur nb de jours d'hospitalisation")
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,50), add=T)
p1 <- hist(public2018$SEU.BAS, breaks = 50)
p2 <- hist(public2018$SEU.HAU, breaks = 250)
plot( p1, col=rgb(0,0,1,1/4), xlim=c(0,50),main = "Seuils sur nb de jours d'hospitalisation")
plot( p2, col=rgb(1,0,0,1/4), xlim=c(0,50), add=T)
# Au global
plot(density(public2018$GHS.PRI), col = "blue", main = "Remboursement du séjour (euros) selon le GHM")
plot(density(public2018$logGHSPrix), col = "blue", main = "Remboursement du séjour (euros) selon le GHM")
# Prix
plot(density(gravite1$GHS.PRI), col = "blue", main = "Remboursement du séjour selon la gravité")
lines(density(gravite2$GHS.PRI), col = "green")
lines(density(gravite3$GHS.PRI), col = "red")
lines(density(gravite4$GHS.PRI), col = "orange")
legend("topright", 95, legend=c("Gravité 1", "Gravité 2", "Gravité 3", "Gravité 4"),
col=c("blue", "green", "red", "orange"), lty=1)
# Log Prix : avec package ggplot
public2018$Gravite <- as.character(substr(public2018$GHM.NRO, 6, 6))
public2018$Gravite[!(public2018$Gravite %in% c("1", "2", "3", "4"))] = "Autre"
ggplot(public2018, aes(logGHSPrix, fill =  public2018$Gravite)) + geom_density(alpha = 0.2)
